#!/bin/bash

# CUBO+ Technical Test Solution by Kaylee Rodriguez
# Fetch and analyze Bitcoin transaction data using mempool.space API

address="32ixEdVJWo3kmvJGMTZq5jAQVZZeuwnqzo"
transactions_file="formatted_transactions.json"
transactions_page_file="transactions_page.json"
batch_size=1000  # Set a batch size to handle large files in parts

# Step 1: Fetch transactions for the address
echo "Fetching transactions for address $address..."
last_seen_txid=""
page=1
while true; do
  if [ -z "$last_seen_txid" ]; then
    url="https://mempool.space/api/address/$address/txs/chain"
  else
    url="https://mempool.space/api/address/$address/txs/chain/$last_seen_txid"
  fi

  curl -sSL "$url" -o "$transactions_page_file"
  num_txs=$(jq '. | length' "$transactions_page_file")

  if [ "$num_txs" -eq 0 ]; then
    echo "No more transactions to fetch."
    break
  fi

  # Append fetched transactions to the main transactions file
  jq -c '.[]' "$transactions_page_file" >> "$transactions_file"

  last_seen_txid=$(jq -r '.[-1].txid' "$transactions_page_file")
  echo "Fetched page $page, last seen txid: $last_seen_txid"
  page=$((page + 1))

  sleep 1  # Avoid hitting rate limits
done

# Step 2: Process the transactions in batches to avoid performance issues
echo "Processing transactions in batches of $batch_size..."
total_transactions=$(wc -l < "$transactions_file")
num_batches=$(( (total_transactions + batch_size - 1) / batch_size ))  # Calculate 
number of batches

total_balance=0

for ((batch=1; batch<=num_batches; batch++)); do
  start=$(( (batch - 1) * batch_size + 1 ))
  end=$(( batch * batch_size ))
  echo "Processing batch $batch of $num_batches..."

  # Extract the current batch of transactions
  sed -n "${start},${end}p" "$transactions_file" > temp_batch.json

  # Remove malformed transactions that cause `jq` errors
  cleaned_batch=$(jq '[.[] | select(.vout and (.vout | type == "array"))]' 
temp_batch.json 2>/dev/null)

  # Check if there are malformed transactions and log them
  malformed_transactions=$(jq '[.[] | select((.vout | type != "array"))]' 
temp_batch.json 2>/dev/null)
  if [ "$(jq length <<< "$malformed_transactions")" -gt 0 ]; then
    echo "Malformed transactions found in batch $batch. Logging to 
'malformed_batch_${batch}.log'..."
    echo "$malformed_transactions" > "malformed_batch_${batch}.log"
  fi

  # Calculate on-chain balance for the cleaned batch
  batch_balance=$(jq '[.[] | .vout[]?.value] | add // 0' <<< "$cleaned_batch")
  
  if [ -z "$batch_balance" ]; then
    batch_balance=0
  fi

  total_balance=$(echo "$total_balance + $batch_balance" | bc)

done

echo "Total on-chain balance: ${total_balance:-0} sats"

# Cleanup
rm temp_batch.json

